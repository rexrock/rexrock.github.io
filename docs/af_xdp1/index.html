<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.70">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="向云原生进击 Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="向云原生进击 Blog Atom Feed"><title data-react-helmet="true">AF_XDP技术详解 | 向云原生进击</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="AF_XDP技术详解 | 向云原生进击"><meta data-react-helmet="true" name="description" content="AFXDP是一个协议族（例如AFNET），主要用于高性能报文处理。"><meta data-react-helmet="true" property="og:description" content="AFXDP是一个协议族（例如AFNET），主要用于高性能报文处理。"><meta data-react-helmet="true" property="og:url" content="https://rexrock.github.io/docs/af_xdp1"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://rexrock.github.io/docs/af_xdp1"><link rel="stylesheet" href="/styles.157dcc77.css">
<link rel="preload" href="/styles.831a2ed6.js" as="script">
<link rel="preload" href="/runtime~main.38468e1e.js" as="script">
<link rel="preload" href="/main.7dbf3cb3.js" as="script">
<link rel="preload" href="/1.074cd580.js" as="script">
<link rel="preload" href="/2.585a96c2.js" as="script">
<link rel="preload" href="/36.a7932f05.js" as="script">
<link rel="preload" href="/37.7782d26b.js" as="script">
<link rel="preload" href="/935f2afb.bb407386.js" as="script">
<link rel="preload" href="/17896441.78c5a4aa.js" as="script">
<link rel="preload" href="/df452b85.54a26b04.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav aria-label="Skip navigation links"><button type="button" tabindex="0" class="skipToContent_11B0">Skip to main content</button></nav><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img src="/img/author.jpg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/author.jpg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">阳仔的博客</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2N3Q"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_3NWk">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_3NWk">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/author.jpg" alt="My Site Logo" class="themedImage_YANc themedImage--light_3CMI navbar__logo"><img src="/img/author.jpg" alt="My Site Logo" class="themedImage_YANc themedImage--dark_3ARp navbar__logo"><strong class="navbar__title">阳仔的博客</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog</a></li><li class="menu__list-item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_vMrn"><div class="docSidebarContainer_3Ak5" role="complementary"><div class="sidebar_3gvy"><div class="menu menu--responsive thin-scrollbar menu_1yIk"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_1CUI" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">eBPF</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/">eBPF的使用限制</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/ebpf2">Run ebpf with tc</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/xdp1">XDP技术简介</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/af_xdp1">AF_XDP技术详解</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/af_xdp2">AF_XDP VS DPDK</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Cilium</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s-net2">Cilium简介</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/cilium1">Cilium datapath梳理</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Kubernetes</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">入门</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s1">使用kubeadm搭建一个k8s集群</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s2">使用kubebuilder创建CRD及Controller</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s3">使用istio + servicemesh搭建服务网格</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">网络</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s-net1">Flannel和Calico简介</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s-net2">Cilium简介</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/k8s-sriov1">玩转sriov-network-device-plugin（一）</a></li></ul></li></ul></li></ul></div></div></div><main class="docMainContainer_2iGs"><div class="container padding-vert--lg docItemWrapper_1bxp"><div class="row"><div class="col docItemCol_U38p"><div class="docItemContainer_a7m4"><article><header><h1 class="docTitle_Oumm">AF_XDP技术详解</h1></header><div class="markdown"><p>AF_XDP是一个协议族（例如AF_NET），主要用于高性能报文处理。</p><p>前文<a href="/docs/xdp1">XDP技术简介</a>中提到过，通过XDP_REDIRECT我们可以将报文重定向到其他设备发送出去或者重定向到其他的CPU继续进行处理。而AF_XDP则利用 bpf_redirect_map()函数，实现将报文重定向到用户态一块指定的内存中，接下来我们看一下这到底是如何做到的。</p><p>我们使用普通的 socket() 系统调用创建一个AF_XDP套接字（XSK）。每个XSK都有两个ring：RX RING 和 TX RING。套接字可以在 RX RING 上接收数据包，并且可以在 TX RING 环上发送数据包。这些环分别通过 setockopts() 的 XDP_RX_RING 和 XDP_TX_RING 进行注册和调整大小。每个 socket 必须至少有一个这样的环。RX或TX描述符环指向存储区域（称为UMEM）中的数据缓冲区。RX和TX可以共享同一UMEM，因此不必在RX和TX之间复制数据包。</p><p>UMEM也有两个 ring：FILL RING 和 COMPLETION RING。应用程序使用 FILL RING 向内核发送可以承载报文的 addr (该 addr 指向UMEM中某个chunk)，以供内核填充RX数据包数据。每当收到数据包，对这些 chunks 的引用就会出现在RX环中。另一方面，COMPLETION RING包含内核已完全传输的 chunks 地址，可以由用户空间再次用于 TX 或 RX。</p><p><img alt="enter description here" src="/assets/images/1614584458041-0f5a49ba346dcdaa3d365927a369dc66.png"></p><blockquote><p>关于ring，熟悉dpdk的同学应该都不陌生，这里只做简单介绍。ring就是一个固定长度的数组，并且同时拥有一个生产者和一个消费者，生产者向数组中逐个填写数据，消费者从数组中逐个读取生产者填充的数据，生产者和消费者都用数组的下标表示，不断累加，像一个环一样不断重复生产然后消费的动作，因此得名ring。
<img alt="enter description here" src="/assets/images/1614166502357-2cae9281e178032779227081f5696a25.png"></p></blockquote><blockquote><p>此外需要注意的事，AF_XDP socket不再通过 send()/recv()等函数实现报文收发，而实通过直接操作ring来实现报文收发。</p><ol><li>FILL RING</li></ol><p><strong>fill_ring 的生产者是用户态程序，消费者是内核态中的XDP程序；</strong></p><p>用户态程序通过 fill_ring 将可以用来承载报文的 UMEM frames 传到内核，然后内核消耗 fill_ring 中的元素（后文统一称为 desc），并将报文拷贝到desc中指定地址（该地址即UMEM frame的地址）；</p><ol start="2"><li>COMPLETION RING</li></ol><p><strong>completion_ring 的生产者是XDP程序，消费者是用户态程序；</strong></p><p>当内核完成XDP报文的发送，会通过 completion_ring 来通知用户态程序，哪些报文已经成功发送，然后用户态程序消耗 completion_ring 中 desc(只是更新consumer计数相当于确认)；</p><ol start="3"><li>RX RING</li></ol><p><strong>rx_ring的生产者是XDP程序，消费者是用户态程序；</strong></p><p>XDP程序消耗 fill_ring，获取可以承载报文的 desc并将报文拷贝到desc中指定的地址，然后将desc填充到 rx_ring 中，并通过socket IO机制通知用户态程序从 rx_ring 中接收报文；</p><ol start="4"><li>TX RING</li></ol><p><strong>tx_ring的生产者是用户态程序，消费者是XDP程序；</strong></p><p>用户态程序将要发送的报文拷贝 tx_ring 中 desc指定的地址中，然后 XDP程序 消耗 tx_ring 中的desc，将报文发送出去，并通过 completion_ring 将成功发送的报文的desc告诉用户态程序；</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="1-用户态程序"></a>1. 用户态程序<a class="hash-link" href="#1-用户态程序" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="11-创建af_xdp的socket"></a>1.1 创建AF_XDP的socket<a class="hash-link" href="#11-创建af_xdp的socket" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-创建AF_XDP的socket codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">xsk_fd = socket(AF_XDP, SOCK_RAW, 0);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这一步没什么好展开的。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="12-为umem申请内存"></a>1.2 为UMEM申请内存<a class="hash-link" href="#12-为umem申请内存" title="Direct link to heading">#</a></h3><p>上文提到UMEM是一块包含固定大小chunk的内存，我们可以通过malloc/mmap/hugepages申请。下文大部分代码出自kernel samples。 </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-samples/bpf/xdpsock_user.c:main() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">    bufs = mmap(NULL, NUM_FRAMES * opt_xsk_frame_size,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         PROT_READ | PROT_WRITE,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         MAP_PRIVATE | MAP_ANONYMOUS | opt_mmap_flags, -1, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    if (bufs == MAP_FAILED) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        printf(&quot;ERROR: mmap failed\n&quot;);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        exit(EXIT_FAILURE);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="13-向af_xdp-socket注册umem"></a>1.3 向AF_XDP socket注册UMEM<a class="hash-link" href="#13-向af_xdp-socket注册umem" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-tools/lib/bpf/xsk.c:xsk_umem__create_v0_0_4() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        struct xdp_umem_reg mr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        memset(&amp;mr, 0, sizeof(mr));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        mr.addr = (uintptr_t)umem_area; // umem_area即上面通过mmap申请到内存起始地址</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        mr.len = size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        mr.chunk_size = umem-&gt;config.frame_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        mr.headroom = umem-&gt;config.frame_headroom;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        mr.flags = umem-&gt;config.flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = setsockopt(umem-&gt;fd, SOL_XDP, XDP_UMEM_REG, &amp;mr, sizeof(mr));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>其中xdp_umem_reg结构定义在 usr/include/linux/if_xdp.h中：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-xdp_umem_reg codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct xdp_umem_reg {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u64 addr; /* Start of packet data area */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u64 len; /* Length of packet data area */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u32 chunk_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u32 headroom;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u32 flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><strong>成员解析：</strong></p><ul><li>addr就是UMEM内存的起始地址；</li><li>len是整个UMEM内存的总长度；</li><li>chunk_size就是每个chunk的大小；</li><li>headroom，如果设置了，那么报文数据将不是从每个chunk的起始地址开始存储，而是要预留出headroom大小的内存，再开始存储报文数据，headroom在隧道网络中非常常见，方便封装外层头部；</li><li>flags, UMEM还有一些更复杂的用法，通过flag设置，后面再进一步展开；</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="14-创建fill-ring-和-completion-ring"></a>1.4 创建FILL RING 和 COMPLETION RING<a class="hash-link" href="#14-创建fill-ring-和-completion-ring" title="Direct link to heading">#</a></h3><p>我们通过 setsockopt() 设置 FILL/COMPLETION/RX/TX ring的大小（在我看来这个过程相当于创建，不设置大小的ring是没有办法使用的）。</p><p>FILL RING 和 COMPLETION RING是UMEM必须，RX和TX则是 AF_XDP socket二选一的，例如AF_XDP socket只收包那么只需要设置RX RING的大小即可。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-tools/lib/bpf/xsk.c:xsk_umem__create_v0_0_4() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = setsockopt(umem-&gt;fd, SOL_XDP, XDP_UMEM_FILL_RING,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         &amp;umem-&gt;config.fill_size,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         sizeof(umem-&gt;config.fill_size));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = setsockopt(umem-&gt;fd, SOL_XDP, XDP_UMEM_COMPLETION_RING,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         &amp;umem-&gt;config.comp_size,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                         sizeof(umem-&gt;config.comp_size));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>上述操作相当于创建了 FILL RING 和 和 COMPLETION RING，创建ring的过程主要是初始化 producer 和 consumer 的下标，以及创建ring数组。</p><p><strong>问题来了：</strong></p><p>上文提到，用户态程序是 FILL RING 的生产者和 CONPLETION RING 的消费者，上面2个 ring 的创建是在内核中创建了 ring 并初始化了其相关成员。那么用户态程序如何操作这两个位于内核中的 ring 呢？所以接下来我们需要将整个 ring 映射到用户态空间。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="15-将fill-ring-映射到用户态"></a>1.5 将FILL RING 映射到用户态<a class="hash-link" href="#15-将fill-ring-映射到用户态" title="Direct link to heading">#</a></h3><p>第一步是获取内核中ring结构各成员的偏移，因为从5.4版本开始后，ring结构中除了 producer、consumer、desc外，又新增了一个flag成员。所以用户态程序需要先获取 ring 结构中各成员的准确便宜，才能在mmap() 之后准确识别内存中各成员位置。 </p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-tools/lib/bpf/xsk.c:xsk_umem__create_v0_0_4() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = xsk_get_mmap_offsets(umem-&gt;fd, &amp;off);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>xsk_get_mmap_offsets() 函数主要是通过getsockopt函数实现这一功能：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-tools/lib/bpf/xsk.c codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = getsockopt(fd, SOL_XDP, XDP_MMAP_OFFSETS, off, &amp;optlen);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return err;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>一切就绪，开始将内核中的 FILL RING 映射到用户态程序中：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-tools/lib/bpf/xsk.c:xsk_umem__create_v0_0_4() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        map = mmap(NULL, off.fr.desc + umem-&gt;config.fill_size * sizeof(__u64),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, umem-&gt;fd,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   XDP_UMEM_PGOFF_FILL_RING);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (map == MAP_FAILED) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        umem-&gt;fill = fill;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fill-&gt;mask = umem-&gt;config.fill_size - 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fill-&gt;size = umem-&gt;config.fill_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fill-&gt;producer = map + off.fr.producer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fill-&gt;consumer = map + off.fr.consumer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fill-&gt;flags = map + off.fr.flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fill-&gt;ring = map + off.fr.desc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fill-&gt;cached_cons = umem-&gt;config.fill_size;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>上面代码需要关注的一点是 mmap() 函数中指定内存的长度——<strong>off.fr.desc + umem-&gt;config.fill_size * sizeof(__u64)</strong>，umem-&gt;config.fill_size * sizeof(__u64)没什么好说的，就是ring数组的长度，而 off.fr.desc 则是ring结构体的长度，我们先看下内核中ring结构的定义：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-usr/include/linux/if_xdp.h codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct xdp_ring_offset {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u64 producer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u64 consumer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u64 desc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这是没有flag的定义，无伤大雅。这里desc的地址其实就是ring数组的起始地址了。而off.fr.desc是desc相对 ring 结构体起始地址的偏移，相当于结构体长度。我们用一张图来看下ring所在内存的结构分布：</p><p><img alt="enter description here" src="data:image/png;base64,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"></p><p>后面一堆赋值代码没什么好讲的，umem-&gt;fill 是用户态程序自定义的一个结构体，其成员 producer、consumer、flags、ring都是指针，分别指向实际ring结构中的对应成员，umem-&gt;fill中的其他成员主要在后面报文收发时用到，起辅助作用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="16-将completion-ring-映射到用户态"></a>1.6 将COMPLETION RING 映射到用户态<a class="hash-link" href="#16-将completion-ring-映射到用户态" title="Direct link to heading">#</a></h3><p>跟上面 FILL RING 的映射一样，只贴代码好了：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-tools/lib/bpf/xsk.c:xsk_umem__create_v0_0_4() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        map = mmap(NULL, off.cr.desc + umem-&gt;config.comp_size * sizeof(__u64),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, umem-&gt;fd,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                   XDP_UMEM_PGOFF_COMPLETION_RING);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (map == MAP_FAILED) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_mmap;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        umem-&gt;comp = comp;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        comp-&gt;mask = umem-&gt;config.comp_size - 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        comp-&gt;size = umem-&gt;config.comp_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        comp-&gt;producer = map + off.cr.producer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        comp-&gt;consumer = map + off.cr.consumer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        comp-&gt;flags = map + off.cr.flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        comp-&gt;ring = map + off.cr.desc;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="17-创建rx-ring和tx-ring然后mmap"></a>1.7 创建RX RING和TX RING然后mmap<a class="hash-link" href="#17-创建rx-ring和tx-ring然后mmap" title="Direct link to heading">#</a></h3><p>这里和 FILL RING 以及 COMPLETION RING的做法基本完全一致，只贴代码：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-tools/lib/bpf/xsk.c:xsk_socket__create() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (rx) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = setsockopt(xsk-&gt;fd, SOL_XDP, XDP_RX_RING,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                 &amp;xsk-&gt;config.rx_size,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                 sizeof(xsk-&gt;config.rx_size));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (tx) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = setsockopt(xsk-&gt;fd, SOL_XDP, XDP_TX_RING,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                 &amp;xsk-&gt;config.tx_size,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                 sizeof(xsk-&gt;config.tx_size));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = xsk_get_mmap_offsets(xsk-&gt;fd, &amp;off);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (rx) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                rx_map = mmap(NULL, off.rx.desc +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                              xsk-&gt;config.rx_size * sizeof(struct xdp_desc),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                              PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                              xsk-&gt;fd, XDP_PGOFF_RX_RING);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if (rx_map == MAP_FAILED) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        goto out_socket;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                rx-&gt;mask = xsk-&gt;config.rx_size - 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                rx-&gt;size = xsk-&gt;config.rx_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                rx-&gt;producer = rx_map + off.rx.producer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                rx-&gt;consumer = rx_map + off.rx.consumer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                rx-&gt;flags = rx_map + off.rx.flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                rx-&gt;ring = rx_map + off.rx.desc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk-&gt;rx = rx;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (tx) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx_map = mmap(NULL, off.tx.desc +</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                              xsk-&gt;config.tx_size * sizeof(struct xdp_desc),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                              PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                              xsk-&gt;fd, XDP_PGOFF_TX_RING);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if (tx_map == MAP_FAILED) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        goto out_mmap_rx;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx-&gt;mask = xsk-&gt;config.tx_size - 1;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx-&gt;size = xsk-&gt;config.tx_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx-&gt;producer = tx_map + off.tx.producer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx-&gt;consumer = tx_map + off.tx.consumer;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx-&gt;flags = tx_map + off.tx.flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx-&gt;ring = tx_map + off.tx.desc;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                tx-&gt;cached_cons = xsk-&gt;config.tx_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk-&gt;tx = tx;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="18-调用bind将af_xdp-socket绑定的指定设备的某一队列"></a>1.8 调用bind()将AF_XDP socket绑定的指定设备的某一队列<a class="hash-link" href="#18-调用bind将af_xdp-socket绑定的指定设备的某一队列" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-bind() codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        sxdp.sxdp_family = PF_XDP;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        sxdp.sxdp_ifindex = xsk-&gt;ifindex;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        sxdp.sxdp_queue_id = xsk-&gt;queue_id;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        sxdp.sxdp_flags = xsk-&gt;config.bind_flags;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = bind(xsk-&gt;fd, (struct sockaddr *)&amp;sxdp, sizeof(sxdp));</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                err = -errno;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                goto out_mmap_tx;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="2-内核态程序"></a>2. 内核态程序<a class="hash-link" href="#2-内核态程序" title="Direct link to heading">#</a></h2><p>相比用户态程序的一堆操作，内核态XDP程序看起来要简单的多。</p><p>在<a href="/docs/xdp1">XDP技术简介</a>我们曾介绍过，XDP程序利用 bpf_reditrct() 函数可以将报文重定向到其他设备发送出去或者重定向到其他CPU继续处理，后来又发展出了bpf_redirect_map()函数，可以将重定向的目的地保存在map中。AF_XDP 正是利用了 bpf_redirect_map() 函数以及 BPF_MAP_TYPE_XSKMAP 类型的 map 实现将报文重定向到用户态程序。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="21-创建bpf_map_type_xskmap类型的map"></a>2.1 创建BPF_MAP_TYPE_XSKMAP类型的map<a class="hash-link" href="#21-创建bpf_map_type_xskmap类型的map" title="Direct link to heading">#</a></h3><p>该类型map的key是网口设备的queue_id，value则是该queue上绑定的AF_XDP socket fd，所以通常需要为每个网口设备各自创建独立的map，并在用户态将对应的queue_id-&gt;xsk_fd存储到map中。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-create codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int xsk_create_bpf_maps(struct xsk_socket *xsk)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int max_queues;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int fd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        max_queues = xsk_get_max_queues(xsk);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (max_queues &lt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return max_queues;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        fd = bpf_create_map_name(BPF_MAP_TYPE_XSKMAP, &quot;xsks_map&quot;,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                 sizeof(int), sizeof(int), max_queues, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (fd &lt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return fd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk-&gt;xsks_map_fd = fd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>bpf_create_map_name参数详解：</p><ul><li>BPF_MAP_TYPE_XSKMAP，map类型</li><li>&quot;xsks_map&quot;，map的名字</li><li>sizeof(int)，分别指定key和vlue的size</li><li>max_queues，map大小</li><li>0, map_flags</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="22-xdp程序代码"></a>2.2 XDP程序代码<a class="hash-link" href="#22-xdp程序代码" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-XDP codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        /* This is the C-program:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         * SEC(&quot;xdp_sock&quot;) int xdp_sock_prog(struct xdp_md *ctx)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         * {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     int index = ctx-&gt;rx_queue_index;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     // A set entry here means that the correspnding queue_id</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     // has an active AF_XDP socket bound to it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     if (bpf_map_lookup_elem(&amp;xsks_map, &amp;index))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *         return bpf_redirect_map(&amp;xsks_map, index, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     return XDP_PASS;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         * }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         */</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>是不是非常的简单，真正的redirect操作只有一行代码。		 </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="23-xdp程序的加载"></a>2.3 XDP程序的加载<a class="hash-link" href="#23-xdp程序的加载" title="Direct link to heading">#</a></h3><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-XDP codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int xsk_load_xdp_prog(struct xsk_socket *xsk)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        static const int log_buf_size = 16 * 1024;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        char log_buf[log_buf_size];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int err, prog_fd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        /* This is the C-program:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         * SEC(&quot;xdp_sock&quot;) int xdp_sock_prog(struct xdp_md *ctx)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         * {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     int index = ctx-&gt;rx_queue_index;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     // A set entry here means that the correspnding queue_id</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     // has an active AF_XDP socket bound to it.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     if (bpf_map_lookup_elem(&amp;xsks_map, &amp;index))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *         return bpf_redirect_map(&amp;xsks_map, index, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         *     return XDP_PASS;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         * }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        struct bpf_insn prog[] = {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                /* r1 = *(u32 *)(r1 + 16) */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_LDX_MEM(BPF_W, BPF_REG_1, BPF_REG_1, 16),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                /* *(u32 *)(r10 - 4) = r1 */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_1, -4),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_MOV64_REG(BPF_REG_1, BPF_REG_0),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_MOV32_IMM(BPF_REG_0, 2),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                /* if r1 == 0 goto +5 */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_JMP_IMM(BPF_JEQ, BPF_REG_1, 0, 5),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                /* r2 = *(u32 *)(r10 - 4) */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                BPF_LD_MAP_FD(BPF_REG_1, xsk-&gt;xsks_map_fd),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_LDX_MEM(BPF_W, BPF_REG_2, BPF_REG_10, -4),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_MOV32_IMM(BPF_REG_3, 0),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_EMIT_CALL(BPF_FUNC_redirect_map),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                /* The jumps are to this instruction */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                BPF_EXIT_INSN(),</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        };</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        size_t insns_cnt = sizeof(prog) / sizeof(struct bpf_insn);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        prog_fd = bpf_load_program(BPF_PROG_TYPE_XDP, prog, insns_cnt,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                   &quot;LGPL-2.1 or BSD-2-Clause&quot;, 0, log_buf,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                   log_buf_size);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (prog_fd &lt; 0) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                pr_warning(&quot;BPF log buffer:\n%s&quot;, log_buf);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return prog_fd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        err = bpf_set_link_xdp_fd(xsk-&gt;ifindex, prog_fd, xsk-&gt;config.xdp_flags);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (err) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                close(prog_fd);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return err;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk-&gt;prog_fd = prog_fd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><strong>XDP程序的load</strong></p><p>调用函数 bpf_load_program() 之前的代码不用关心。通常 eBPF 程序使用 C 语言的一个子集（restricted C）编写，然后通过 LLVM 编译成字节码注入到内核执行。由于本例中XDP程序代码比较简单，功力深厚的作者直接将其编写为 eBPF（JIT）可识别的字节码，然后直接调用 bpf_load_program() 函数将字节码程序加载到内核中。</p><p><strong>XDP程序的attach</strong></p><p>XDP程序加载成功会返回对应的fd（后面统称为prog_fd），但是此时XDP程序还不会被执行（所有的eBPF都需要经过load和attach两步才能被触发执行，load只是将程序加载到内核中，attach将程序添加到hook点后，程序才能真正被触发执行）。我们调用函数 bpf_set_link_xdp_fd() 函数将XDP程序attach到指定网口设备的驱动中的hook点。</p><blockquote><p><strong>注意：</strong> AF_XDP socket是跟指定网口设备的队列绑定，而XDP程序则是跟指定的网口设备绑定（attach）。</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="3-回到用户态，让程序run起来"></a>3. 回到用户态，让程序run起来<a class="hash-link" href="#3-回到用户态，让程序run起来" title="Direct link to heading">#</a></h2><p>经过前面两步，AF_XDP socket、UMEM、FILL/COMPLETION/RX/TX RING 都创建设置好了，XSKMAP 和XDP PROG 也都加载好了。但是要想让XDP程序把报文传到用户态程序，我们还得再进行两补操作。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="31-将af_xdp-socket存储到xskmap中"></a>3.1 将AF_XDP socket存储到XSKMAP中<a class="hash-link" href="#31-将af_xdp-socket存储到xskmap中" title="Direct link to heading">#</a></h3><p>前面介绍XSKMAP的时候，大家应该都想到这一步了，所以只贴代码不说话：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-Update codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static int xsk_set_bpf_maps(struct xsk_socket *xsk)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return bpf_map_update_elem(xsk-&gt;xsks_map_fd, &amp;xsk-&gt;queue_id,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                   &amp;xsk-&gt;fd, 0);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="32-标题先卖个关子"></a>3.2 标题先卖个关子<a class="hash-link" href="#32-标题先卖个关子" title="Direct link to heading">#</a></h3><p>前面我们介绍过4种ring，分别对应收发包两个场景（收包：FILL/RX ring，发包：TX/COMPLETION RING）,我画个图分别描述一下收发包场景。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="321-先看收包"></a>3.2.1 先看收包<a class="hash-link" href="#321-先看收包" title="Direct link to heading">#</a></h4><p><img alt="收包" src="/assets/images/1614242674670-f94d20b8152dcd95b0d6a3e9e4f37e46.png">
收包过程是由XDP程序触发的，但是XDP程序收包，需要依赖用户态程序填充FILL RING，将可以承载报文的desc告诉XDP程序。所以在用户态程序初始化阶段，我们需要先填充FILL RING，直接看代码：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-INIT codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ret = xsk_ring_prod__reserve(&amp;xsk-&gt;umem-&gt;fq,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                     XSK_RING_PROD__DEFAULT_NUM_DESCS,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                     &amp;idx);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (ret != XSK_RING_PROD__DEFAULT_NUM_DESCS)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                exit_with_error(-ret);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for (i = 0; i &lt; XSK_RING_PROD__DEFAULT_NUM_DESCS; i++)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                *xsk_ring_prod__fill_addr(&amp;xsk-&gt;umem-&gt;fq, idx++) =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        i * opt_xsk_frame_size;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk_ring_prod__submit(&amp;xsk-&gt;umem-&gt;fq,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                              XSK_RING_PROD__DEFAULT_NUM_DESCS);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>三个经过封装的函数，看起来不明觉厉，咱们一个一个看：</p><p><strong>1. xsk_ring_prod__reserve</strong></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-rust codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static inline size_t xsk_ring_prod__reserve(struct xsk_ring_prod *prod,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                            size_t nb, __u32 *idx)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (xsk_prod_nb_free(prod, nb) &lt; nb)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        *idx = prod-&gt;cached_prod;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        prod-&gt;cached_prod += nb;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return nb;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>这个函数前面先判断一下：我现在想生产nb个数据，ring里有没有足够的地方放啊？没有的话直接退出，等会再试试。</p><blockquote><p>vhostuser里再这块有个BUG，前端程序想发包发现ring里空间不够了，而后端驱动处理又由于有有问题的判断，导致报文已发的报文一直不被处理，结果造成死锁，以后别的文章中再介绍吧。</p></blockquote><p>如果有足够的空间，那么会将生产者当前下标（cached_prog）赋值给idx，因为退出函数后会根据从这个idx指向的位置开始生产desc，最后cached_prod + nb。</p><p><strong>为什么要有个cached_prog呢？</strong></p><p>因为生产数据这个过程需要分几步完成，所以这个东西应该为了多线程同步吧。</p><p><strong>2. xsk_ring_prod__fill_addr</strong></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-rust codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static inline __u64 *xsk_ring_prod__fill_addr(struct xsk_ring_prod *fill,</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                                              __u32 idx)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u64 *addrs = (__u64 *)fill-&gt;ring;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return &amp;addrs[idx &amp; fill-&gt;mask];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>看这段代码前，我们先看下ring中元素xdp_desc的成员结构：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-rust codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">struct xdp_desc {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u64 addr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u32 len;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        __u32 options;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><strong>成员解析</strong></p><ul><li>addr指向UMEM中某个帧的具体位置，并且不是真正的虚拟内存地址，而是相对UMEM内存起始地址的偏移。</li><li>len则是指报文的具体的长度，当XDP程序向desc填充报文的时候需要设置len，但是用户态程序向FILL RING中填充desc则不用关心len。</li></ul><p>所以上面xsk_ring_prod__fill_addr的功能就好理解了，返回的ring中下标为idx处的desc中addr的指针；并且在函数返回后对addr进行了赋值，再看下这块代码，可以看到赋值给addr是个偏移量：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-rust codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for (i = 0; i &lt; XSK_RING_PROD__DEFAULT_NUM_DESCS; i++)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                *xsk_ring_prod__fill_addr(&amp;xsk-&gt;umem-&gt;fq, idx++) =</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        i * opt_xsk_frame_size;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><ol start="3"><li>xsk_ring_prod__submit</li></ol><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-rust codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static inline void xsk_ring_prod__submit(struct xsk_ring_prod *prod, size_t nb)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        /* Make sure everything has been written to the ring before indicating</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         * this to the kernel by writing the producer pointer.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">         */</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        libbpf_smp_wmb();</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        *prod-&gt;producer += nb;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>数据填充完毕，更新生产者下标。</p><blockquote><p>说明：下标永远指向下一个可填充数据位置。</p></blockquote><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="322-再看发包"></a>3.2.2 再看发包<a class="hash-link" href="#322-再看发包" title="Direct link to heading">#</a></h4><p><img alt="发包" src="/assets/images/1614243219906-ec4adae9f8e814b6cacbf821448b37db.png"></p><p>发包真的没啥好说的。初始化的时候不用管，想发包的时候直接就发啦。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="4-收包流程解析"></a>4. 收包流程解析<a class="hash-link" href="#4-收包流程解析" title="Direct link to heading">#</a></h2><p><img alt="收包" src="/assets/images/1614242674670-f94d20b8152dcd95b0d6a3e9e4f37e46.png">
AF_XDP socket毕竟也是socket，所以select/poll/epoll这些函数都能用的，怎么用这里不介绍了。</p><p>我们只看具体从一个AF_XDP socket收包的过程:</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-receive codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static void rx_drop(struct xsk_socket_info *xsk, struct pollfd *fds)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        unsigned int rcvd, i;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        u32 idx_rx = 0, idx_fq = 0;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        int ret;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        rcvd = xsk_ring_cons__peek(&amp;xsk-&gt;rx, BATCH_SIZE, &amp;idx_rx);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        if (!rcvd) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if (xsk_ring_prod__needs_wakeup(&amp;xsk-&gt;umem-&gt;fq))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        ret = poll(fds, num_socks, opt_timeout);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                return;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        ret = xsk_ring_prod__reserve(&amp;xsk-&gt;umem-&gt;fq, rcvd, &amp;idx_fq);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        while (ret != rcvd) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if (ret &lt; 0)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        exit_with_error(-ret);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                if (xsk_ring_prod__needs_wakeup(&amp;xsk-&gt;umem-&gt;fq))</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                        ret = poll(fds, num_socks, opt_timeout);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                ret = xsk_ring_prod__reserve(&amp;xsk-&gt;umem-&gt;fq, rcvd, &amp;idx_fq);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for (i = 0; i &lt; rcvd; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                u64 addr = xsk_ring_cons__rx_desc(&amp;xsk-&gt;rx, idx_rx)-&gt;addr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                u32 len = xsk_ring_cons__rx_desc(&amp;xsk-&gt;rx, idx_rx++)-&gt;len;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                u64 orig = xsk_umem__extract_addr(addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                addr = xsk_umem__add_offset_to_addr(addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                char *pkt = xsk_umem__get_data(xsk-&gt;umem-&gt;buffer, addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                hex_dump(pkt, len, addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                *xsk_ring_prod__fill_addr(&amp;xsk-&gt;umem-&gt;fq, idx_fq++) = orig;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk_ring_prod__submit(&amp;xsk-&gt;umem-&gt;fq, rcvd);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk_ring_cons__release(&amp;xsk-&gt;rx, rcvd);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        xsk-&gt;rx_npkts += rcvd;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>该函数并没有对报文做什么复杂处理，只是hex_dump了一下，整个收发包分五个步骤：</p><p><strong>1. xsk_ring_cons__peek()</strong></p><p>开始对RX RING进行消费，返回消费者下标和消费个数，并累加cached_cons；</p><p><strong>2. xsk_ring_prod__reserve</strong></p><p>开始对FILL RING进行生产，返回生产者下标和生产个数，并累加cached_prod;</p><p><strong>3. 报文处理</strong></p><p>处理从RX RING中收到的报文，并回填到FILL RING中；</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-handle codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">        for (i = 0; i &lt; rcvd; i++) {</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                u64 addr = xsk_ring_cons__rx_desc(&amp;xsk-&gt;rx, idx_rx)-&gt;addr;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                u32 len = xsk_ring_cons__rx_desc(&amp;xsk-&gt;rx, idx_rx++)-&gt;len;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                u64 orig = xsk_umem__extract_addr(addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                addr = xsk_umem__add_offset_to_addr(addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                char *pkt = xsk_umem__get_data(xsk-&gt;umem-&gt;buffer, addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                hex_dump(pkt, len, addr);</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">                *xsk_ring_prod__fill_addr(&amp;xsk-&gt;umem-&gt;fq, idx_fq++) = orig;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>从desc中读取addr，并通过 xsk_umem__get_data() 函数得到报文真正的虚拟地址，然后 hex_dump()下。</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-get codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">static inline void *xsk_umem__get_data(void *umem_area, __u64 addr)</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        return &amp;((char *)umem_area)[addr];</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p>然后将处理完报文所在的 UMEM 帧回填到FILL RING中：</p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-rust codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">*xsk_ring_prod__fill_addr(&amp;xsk-&gt;umem-&gt;fq, idx_fq++) = orig;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><strong>4. xsk_ring_prod__submit(&amp;xsk-&gt;umem-&gt;fq, rcvd)</strong></p><p>完成对RX RING的消费，更新消费者下标；</p><p><strong>5. xsk_ring_cons__release(&amp;xsk-&gt;rx, rcvd)</strong></p><p>完成对FILL RING的生产，更新生产者下标；</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_prK2" id="5-结语"></a>5. 结语<a class="hash-link" href="#5-结语" title="Direct link to heading">#</a></h2><p>关于AF_XDP的使用及背后原理暂且分析到这，目前AF_XDP已经在ovs、dpdk、cilium中应用，相应的文档下面有链接。如有错误纰漏，欢迎大家拍砖。</p><p><strong>相关代码均出自kernel：</strong></p><div class="mdxCodeBlock_1zKU"><div class="codeBlockContent_actS"><div tabindex="0" class="prism-code language-crystal codeBlock_tuNs thin-scrollbar"><div class="codeBlockLines_3uvA" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">samples/bpf/xdpsock_user.c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tools/lib/bpf/xsk.c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tools/lib/bpf/xsk.h</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">net/xdp/xsk.c</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">net/xdp/xsk.h</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">usr/include/linux/if_xdp.h</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_2GIj">Copy</button></div></div><p><strong>相关参考文档如下：</strong></p><p><a href="https://www.kernel.org/doc/html/latest/networking/af_xdp.html" target="_blank" rel="noopener noreferrer">Kernel document for AF_XDP</a></p><p><a href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html" target="_blank" rel="noopener noreferrer">Man for bpf</a></p><p><a href="https://docs.openvswitch.org/en/latest/intro/install/afxdp/" target="_blank" rel="noopener noreferrer">Openvswitch and XDP</a></p><p><a href="http://doc.dpdk.org/guides/nics/af_xdp.html" target="_blank" rel="noopener noreferrer">DPDK and XDP</a></p><p><a href="https://www.dpdk.org/wp-content/uploads/sites/35/2019/07/14-AF_XDP-dpdk-summit-china-2019.pdf" target="_blank" rel="noopener noreferrer">性能对比</a></p><p><a href="https://cloud.tencent.com/developer/article/1644458" target="_blank" rel="noopener noreferrer">编译内核源码中的示例代码</a></p></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/facebook/docusaurus/edit/master/website/docs/af_xdp1.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2LL7"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/xdp1"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« XDP技术简介</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/af_xdp2"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">AF_XDP VS DPDK »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_2xL- thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1-用户态程序" class="table-of-contents__link">1. 用户态程序</a><ul><li><a href="#11-创建af_xdp的socket" class="table-of-contents__link">1.1 创建AF_XDP的socket</a></li><li><a href="#12-为umem申请内存" class="table-of-contents__link">1.2 为UMEM申请内存</a></li><li><a href="#13-向af_xdp-socket注册umem" class="table-of-contents__link">1.3 向AF_XDP socket注册UMEM</a></li><li><a href="#14-创建fill-ring-和-completion-ring" class="table-of-contents__link">1.4 创建FILL RING 和 COMPLETION RING</a></li><li><a href="#15-将fill-ring-映射到用户态" class="table-of-contents__link">1.5 将FILL RING 映射到用户态</a></li><li><a href="#16-将completion-ring-映射到用户态" class="table-of-contents__link">1.6 将COMPLETION RING 映射到用户态</a></li><li><a href="#17-创建rx-ring和tx-ring然后mmap" class="table-of-contents__link">1.7 创建RX RING和TX RING然后mmap</a></li><li><a href="#18-调用bind将af_xdp-socket绑定的指定设备的某一队列" class="table-of-contents__link">1.8 调用bind()将AF_XDP socket绑定的指定设备的某一队列</a></li></ul></li><li><a href="#2-内核态程序" class="table-of-contents__link">2. 内核态程序</a><ul><li><a href="#21-创建bpf_map_type_xskmap类型的map" class="table-of-contents__link">2.1 创建BPF_MAP_TYPE_XSKMAP类型的map</a></li><li><a href="#22-xdp程序代码" class="table-of-contents__link">2.2 XDP程序代码</a></li><li><a href="#23-xdp程序的加载" class="table-of-contents__link">2.3 XDP程序的加载</a></li></ul></li><li><a href="#3-回到用户态，让程序run起来" class="table-of-contents__link">3. 回到用户态，让程序run起来</a><ul><li><a href="#31-将af_xdp-socket存储到xskmap中" class="table-of-contents__link">3.1 将AF_XDP socket存储到XSKMAP中</a></li><li><a href="#32-标题先卖个关子" class="table-of-contents__link">3.2 标题先卖个关子</a></li></ul></li><li><a href="#4-收包流程解析" class="table-of-contents__link">4. 收包流程解析</a></li><li><a href="#5-结语" class="table-of-contents__link">5. 结语</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Style Guide</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/doc2/">Second Doc</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Stack Overflow</a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord</a></li><li class="footer__item"><a href="https://twitter.com/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/styles.831a2ed6.js"></script>
<script src="/runtime~main.38468e1e.js"></script>
<script src="/main.7dbf3cb3.js"></script>
<script src="/1.074cd580.js"></script>
<script src="/2.585a96c2.js"></script>
<script src="/36.a7932f05.js"></script>
<script src="/37.7782d26b.js"></script>
<script src="/935f2afb.bb407386.js"></script>
<script src="/17896441.78c5a4aa.js"></script>
<script src="/df452b85.54a26b04.js"></script>
</body>
</html>